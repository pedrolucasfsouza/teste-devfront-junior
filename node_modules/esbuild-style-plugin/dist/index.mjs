var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/utils.ts
import { TextDecoder } from "util";
import path from "path";
import fs from "fs";
var getModule, renderStylus, renderStyle;
var init_utils = __esm({
  "src/utils.ts"() {
    getModule = async (moduleName) => {
      try {
        return (await import(moduleName)).default;
      } catch {
        throw new Error(`Missing module. Please install '${moduleName}' package.`);
      }
    };
    renderStylus = async (css, options) => {
      const stylus = await getModule("stylus");
      return new Promise((resolve, reject) => {
        stylus.render(css, options, (err, css2) => {
          if (err)
            reject(err);
          resolve(css2);
        });
      });
    };
    renderStyle = async (filePath, options = {}) => {
      const { ext } = path.parse(filePath);
      if (ext === ".css") {
        return (await fs.promises.readFile(filePath)).toString();
      }
      if (ext === ".sass" || ext === ".scss") {
        const sassOptions = options.sassOptions || {};
        const sass = await getModule("sass");
        return sass.renderSync({ ...sassOptions, file: filePath }).css.toString();
      }
      if (ext === ".styl") {
        const stylusOptions = options.stylusOptions || {};
        const source = await fs.promises.readFile(filePath);
        return await renderStylus(new TextDecoder().decode(source), { ...stylusOptions, filename: filePath });
      }
      if (ext === ".less") {
        const lestOptions = options.lessOptions || {};
        const source = await fs.promises.readFile(filePath);
        const less = await getModule("less");
        return (await less.render(new TextDecoder().decode(source), { ...lestOptions, filename: filePath })).css;
      }
      throw new Error(`Can't render this style '${ext}'.`);
    };
  }
});

// src/index.ts
import path2 from "path";
import fs2 from "fs";
import resolveFile from "resolve-file";
import postcss from "postcss";
import cssModules from "postcss-modules";
import temp from "temp";
var require_src = __commonJS({
  "src/index.ts"(exports, module) {
    init_utils();
    var LOAD_TEMP_NAMESPACE = "temp_stylePlugin";
    var LOAD_STYLE_NAMESPACE = "stylePlugin";
    var styleFilter = /.\.(css|sass|scss|less|styl)$/;
    var handleCSSModules = (mapping, cssModulesOptions) => {
      const _getJSON = cssModulesOptions.getJSON;
      return cssModules({
        ...cssModulesOptions,
        getJSON: (cssFilename, json, outputFilename) => {
          if (typeof _getJSON === "function")
            _getJSON(cssFilename, json, outputFilename);
          mapping.data = JSON.stringify(json, null, 2);
        }
      });
    };
    var onStyleResolve = async (args) => {
      const { namespace, resolveDir } = args;
      let fullPath = resolveFile(args.path, {});
      if (!fullPath)
        fullPath = path2.resolve(args.resolveDir, args.path);
      if (namespace === LOAD_STYLE_NAMESPACE) {
        return {
          path: fullPath,
          namespace: LOAD_TEMP_NAMESPACE,
          pluginData: { resolveDir }
        };
      }
      return {
        path: fullPath,
        namespace: LOAD_STYLE_NAMESPACE,
        watchFiles: [fullPath]
      };
    };
    var onTempLoad = async (args) => {
      const { pluginData } = args;
      const data = await fs2.promises.readFile(args.path);
      return {
        resolveDir: pluginData.resolveDir,
        contents: data,
        loader: "css"
      };
    };
    var onStyleLoad = (options) => async (args) => {
      const extract = options.extract === void 0 ? true : options.extract;
      const cssModulesMatch = options.cssModulesMatch || /\.module\./;
      const isCSSModule = args.path.match(cssModulesMatch);
      const cssModulesOptions = options.cssModulesOptions || {};
      const renderOptions = options.renderOptions;
      let css = await renderStyle(args.path, renderOptions);
      let mapping = { data: {} };
      let plugins = options.postcss || [];
      let injectMapping = false;
      let contents = "";
      if (isCSSModule) {
        plugins = [handleCSSModules(mapping, cssModulesOptions), ...plugins];
        injectMapping = true;
      }
      if (plugins.length > 0) {
        css = (await postcss(plugins).process(css, { from: args.path })).css;
        if (injectMapping)
          contents += `export default ${mapping.data};`;
      }
      if (extract) {
        const writestream = temp.createWriteStream({ suffix: ".css" });
        writestream.write(css);
        writestream.end();
        contents += `import ${JSON.stringify(writestream.path)};`;
      }
      return {
        resolveDir: path2.dirname(args.path),
        contents
      };
    };
    var stylePlugin = (options = {}) => ({
      name: "esbuild-style-plugin",
      setup: (build) => {
        build.onResolve({ filter: styleFilter }, onStyleResolve);
        build.onLoad({ filter: /.*/, namespace: LOAD_TEMP_NAMESPACE }, onTempLoad);
        build.onLoad({ filter: /.*/, namespace: LOAD_STYLE_NAMESPACE }, onStyleLoad(options));
      }
    });
    module.exports = stylePlugin;
  }
});
export default require_src();

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
var import_path2 = __toModule(require("path"));
var import_fs2 = __toModule(require("fs"));
var import_resolve_file = __toModule(require("resolve-file"));
var import_postcss = __toModule(require("postcss"));
var import_postcss_modules = __toModule(require("postcss-modules"));
var import_temp = __toModule(require("temp"));

// src/utils.ts
var import_util = __toModule(require("util"));
var import_path = __toModule(require("path"));
var import_fs = __toModule(require("fs"));
var getModule = async (moduleName) => {
  try {
    return (await import(moduleName)).default;
  } catch {
    throw new Error(`Missing module. Please install '${moduleName}' package.`);
  }
};
var renderStylus = async (css, options) => {
  const stylus = await getModule("stylus");
  return new Promise((resolve, reject) => {
    stylus.render(css, options, (err, css2) => {
      if (err)
        reject(err);
      resolve(css2);
    });
  });
};
var renderStyle = async (filePath, options = {}) => {
  const { ext } = import_path.default.parse(filePath);
  if (ext === ".css") {
    return (await import_fs.default.promises.readFile(filePath)).toString();
  }
  if (ext === ".sass" || ext === ".scss") {
    const sassOptions = options.sassOptions || {};
    const sass = await getModule("sass");
    return sass.renderSync({ ...sassOptions, file: filePath }).css.toString();
  }
  if (ext === ".styl") {
    const stylusOptions = options.stylusOptions || {};
    const source = await import_fs.default.promises.readFile(filePath);
    return await renderStylus(new import_util.TextDecoder().decode(source), { ...stylusOptions, filename: filePath });
  }
  if (ext === ".less") {
    const lestOptions = options.lessOptions || {};
    const source = await import_fs.default.promises.readFile(filePath);
    const less = await getModule("less");
    return (await less.render(new import_util.TextDecoder().decode(source), { ...lestOptions, filename: filePath })).css;
  }
  throw new Error(`Can't render this style '${ext}'.`);
};

// src/index.ts
var LOAD_TEMP_NAMESPACE = "temp_stylePlugin";
var LOAD_STYLE_NAMESPACE = "stylePlugin";
var styleFilter = /.\.(css|sass|scss|less|styl)$/;
var handleCSSModules = (mapping, cssModulesOptions) => {
  const _getJSON = cssModulesOptions.getJSON;
  return (0, import_postcss_modules.default)({
    ...cssModulesOptions,
    getJSON: (cssFilename, json, outputFilename) => {
      if (typeof _getJSON === "function")
        _getJSON(cssFilename, json, outputFilename);
      mapping.data = JSON.stringify(json, null, 2);
    }
  });
};
var onStyleResolve = async (args) => {
  const { namespace, resolveDir } = args;
  let fullPath = (0, import_resolve_file.default)(args.path, {});
  if (!fullPath)
    fullPath = import_path2.default.resolve(args.resolveDir, args.path);
  if (namespace === LOAD_STYLE_NAMESPACE) {
    return {
      path: fullPath,
      namespace: LOAD_TEMP_NAMESPACE,
      pluginData: { resolveDir }
    };
  }
  return {
    path: fullPath,
    namespace: LOAD_STYLE_NAMESPACE,
    watchFiles: [fullPath]
  };
};
var onTempLoad = async (args) => {
  const { pluginData } = args;
  const data = await import_fs2.default.promises.readFile(args.path);
  return {
    resolveDir: pluginData.resolveDir,
    contents: data,
    loader: "css"
  };
};
var onStyleLoad = (options) => async (args) => {
  const extract = options.extract === void 0 ? true : options.extract;
  const cssModulesMatch = options.cssModulesMatch || /\.module\./;
  const isCSSModule = args.path.match(cssModulesMatch);
  const cssModulesOptions = options.cssModulesOptions || {};
  const renderOptions = options.renderOptions;
  let css = await renderStyle(args.path, renderOptions);
  let mapping = { data: {} };
  let plugins = options.postcss || [];
  let injectMapping = false;
  let contents = "";
  if (isCSSModule) {
    plugins = [handleCSSModules(mapping, cssModulesOptions), ...plugins];
    injectMapping = true;
  }
  if (plugins.length > 0) {
    css = (await (0, import_postcss.default)(plugins).process(css, { from: args.path })).css;
    if (injectMapping)
      contents += `export default ${mapping.data};`;
  }
  if (extract) {
    const writestream = import_temp.default.createWriteStream({ suffix: ".css" });
    writestream.write(css);
    writestream.end();
    contents += `import ${JSON.stringify(writestream.path)};`;
  }
  return {
    resolveDir: import_path2.default.dirname(args.path),
    contents
  };
};
var stylePlugin = (options = {}) => ({
  name: "esbuild-style-plugin",
  setup: (build) => {
    build.onResolve({ filter: styleFilter }, onStyleResolve);
    build.onLoad({ filter: /.*/, namespace: LOAD_TEMP_NAMESPACE }, onTempLoad);
    build.onLoad({ filter: /.*/, namespace: LOAD_STYLE_NAMESPACE }, onStyleLoad(options));
  }
});
module.exports = stylePlugin;
